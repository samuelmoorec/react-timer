{"version":3,"sources":["components/Lap.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Lap","laps","html","lastLapTime","map","lap","index","className","toFixed","currentLap","lastLap","diff","Math","abs","calcLapDifference","generateLaps","App","useState","timeStarted","setTimeStarted","timeFinished","setTimeFinished","timer","setTimer","isTimerActive","setisTimerActive","prevTimes","setPrevTimes","setLaps","useEffect","timerID","setInterval","tick","clearInterval","displayTimer","undefined","Moment","addupTimes","sum","forEach","num","addPrevTime","arr","push","onClick","valueOf","disabled","length","Number","parseFloat","reduce","total","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.cc7be9b9.chunk.js","sourcesContent":["import React from 'react';\r\nimport './lap.css';\r\n\r\ninterface iProps {\r\n    laps: number[];\r\n}\r\n\r\nconst Lap = ({laps} : iProps) => {\r\n\r\n    const calcLapDifference = (currentLap : number, lastLap : number) =>{\r\n        let diff = currentLap - lastLap;\r\n            if(diff > 0){\r\n                return <span className=\"slowerLap lapDifference\">{diff.toFixed(2)}</span>\r\n            }else{\r\n                return <span className=\"fasterLap lapDifference\">{Math.abs(diff).toFixed(2)}</span>\r\n            }\r\n    }\r\n    \r\n    const generateLaps = () => {\r\n        let lastLapTime = 0;\r\n        let html : JSX.Element;\r\n        \r\n        let toreturn = laps.map((lap, index) => {\r\n        \r\n        \r\n          if(index > 0){\r\n            html = <p className=\"lap\"><span className=\"lapTitleAndIndex\"><span className=\"lapTitle\" >lap</span><span className=\"lapIndex\">{index + 1}</span></span><span className=\"timeAndDiff\"><span className=\"lapTime\">{lap.toFixed(2)}</span>   {calcLapDifference(lap,lastLapTime)}</span></p>\r\n          }else{\r\n            lastLapTime = lap;\r\n            html = <p className=\"lap firstLap\"><span className=\"lapTitleAndIndex\"><span className=\"lapTitle\" >lap</span><span className=\"lapIndex\">{index + 1}</span></span><span className=\"lapTime\">{lap.toFixed(2)}</span></p>\r\n          }\r\n\r\n          lastLapTime = lap;\r\n          return html;\r\n          });\r\n\r\n         return toreturn;\r\n          \r\n    }\r\n\r\n    return <div>{generateLaps()}</div>\r\n    \r\n}\r\n\r\nexport default Lap;\r\n","import React, {useState, useEffect} from 'react';\nimport Moment from 'moment'\nimport Lap from './components/Lap';\nimport './App.css';\n\nconst App = () => {\n\n  const [timeStarted, setTimeStarted] = useState<number>();\n  const [timeFinished, setTimeFinished] = useState<number>();\n  const [timer, setTimer] = useState<string>(\"0.00\");\n  const [isTimerActive, setisTimerActive] = useState<boolean>(false);\n  const [prevTimes, setPrevTimes] = useState<number[]>([]);\n  const [laps, setLaps] = useState<number[]>([]);\n\n  useEffect(() => {\n\n    var timerID = setInterval(() => tick()\n    , 1);\n    return function cleanup() {\n      clearInterval(timerID);\n    }\n  });\n\n\n  const tick = () => {\n    if(isTimerActive){\n    setTimer(displayTimer());\n    }\n  }\n\n  const toggleTimer = () => {\n\n    if(!isTimerActive){\n      setTimeStarted(Moment().valueOf());\n    }else{\n      setTimeFinished(Moment().valueOf());\n      setPrevTimes(addPrevTime(prevTimes))\n    }\n\n\n    setisTimerActive((timer: boolean) => !timer)\n  };\n\n  const displayTimer = () => {\n    if(timeStarted === undefined){\n      return \"0.00\"\n    }else if(timeFinished === undefined){\n      return (Moment().diff(Moment(timeStarted),'milliseconds')/1000).toFixed(2);\n    }else if(timeFinished !== undefined){\n      return ((Moment().diff(Moment(timeStarted),'milliseconds') + addupTimes())/1000).toFixed(2);\n    }else{\n      return \"\"\n    }\n\n  }\n\n\n  const addupTimes = () => {\n    let sum = 0;\n    prevTimes.forEach(num => sum += num);\n    return sum;\n  }\n\n  const addPrevTime = (arr: number[]) => {\n    arr.push(Moment().diff(Moment(timeStarted),'milliseconds'));\n    \n    return arr;\n  }\n\n  const toggleButtonText = () => {\n    if(isTimerActive)\n    return \"Pause Timer\"\n    else return \"Start Timer\"\n  }\n\n  const reset = () => {\n    setTimer(\"0.00\");\n    setisTimerActive(false);\n    setPrevTimes([]);\n    setLaps([]);\n  }\n\n  const addLap = () => {\n    if(isTimerActive){\n      if(laps.length === 0){\n        laps.push(Number.parseFloat(timer));\n        setLaps(laps);\n      }else{\n        laps.push((Number.parseFloat(timer) - laps.reduce((total, num) => total + num)));\n        setLaps(laps);\n      }\n    }\n  }\n\n  const lapAverage = () =>{\n    if(laps.length > 0){\n    let sum = laps.reduce((sum, num) => sum + num);\n    return (sum/laps.length).toFixed(2);\n    }else return \"0.00\"\n  }\n\n  return (\n    <div className=\"timer_container\">\n      <p className=\"timer\">{timer}</p>\n      <button onClick={toggleTimer}>{toggleButtonText()}</button>\n      \n      <button disabled={isTimerActive} onClick={reset}>Reset</button>\n      \n      <button disabled={!isTimerActive} onClick={addLap}>Lap</button>\n      <p>Lap Average {lapAverage()}s</p>\n      <Lap laps={laps} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}